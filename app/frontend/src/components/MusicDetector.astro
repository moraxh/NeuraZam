---
  import { Icon } from 'astro-icon/components'
  import Spinner from './Spinner.astro'
  import SpinnerFailed from './SpinnerFailed.astro'
---

<dialog id="stateDialog" class="bg-transparent backdrop:bg-black/70 border-none outline-none absolute min-w-screen w-screen min-h-screen h-screen text-center z-50 top-0">
  <div id="stateVerbose" class="flex flex-col justify-start items-center gap-10 sm:gap-20 py-16 px-5 sm:py-27 sm:px-10 h-full">
    <section class="flex flex-col justify-center gap-2">
      <h2 class="text-3xl sm:text-7xl font-bold">The model is being trained</h2>
      <p class="sm:text-3xl opacity-60">Please wait until the process is finished...</p>
    </section>

    <!-- Spinner -->
    <section id="spinner" class="flex justify-center items-center h-full">
      <Spinner />
    </section>

    <!-- Chart and progress bar -->
    <section id="chart_progress" class="flex flex-col justify-between h-full" hidden>
      <div class="h-64 sm:h-96 flex justify-center items-center">
        <canvas class="max-w-[90vw]" id="modelTrainingChart"></canvas>
      </div>

      <div class="flex flex-col gap-2 items-center justify-center w-full max-w-screen">
        <p id="modelTrainingProgressText" class="text-5xl sm:text-7xl">50%</p>
        <progress id="modelTrainingProgress" class="w-[900px] max-w-[90%] h-2 sm:h-2.5" max="100" value="0"></progress>
        <p id="modelTrainingETA" class="text-white/50 text-lg"></p>
      </div>
    </section>
  </div>

  <div id="stateFailed" class="flex flex-col justify-start items-center gap-20 py-16 px-5 sm:py-27 sm:px-10 h-full" hidden>
    <section class="flex flex-col justify-center gap-2">
      <h2 class="text-5xl sm:text-7xl font-bold">Cannot connect to the server</h2>
      <p class="text-xl sm:text-3xl opacity-60">Retrying the connection...</p>
    </section>

    <!-- Spinner failed -->
    <section id="spinner" class="flex justify-center items-center h-full">
      <SpinnerFailed />
    </section>
  </div>
</dialog>

<section class="flex items-center justify-center w-full pt-40">
  <div id="listeningButton">
    <button class="bg-radial from-primary to-secondary transition-all w-60 h-60 rounded-full flex justify-center items-center hover:cursor-pointer hover:scale-105 hover:brightness-90 hover:*:scale-[115%]">
      <Icon class="w-20 h-20" name="lucide:mic" />
    </button>
  </div>
</section>

<style>
  @import url('../styles/global.css');

  button {
    filter: drop-shadow(0 0 2rem var(--color-primary-50));
  }

  #stateDialog {
    transition: all .2s ease-in-out;
    opacity: 0;
    scale: .5;
  }

  #stateDialog.show {
    opacity: 1;
    scale: 1;
  }

  #stateDialog.show[open]::backdrop {
    animation: backdropBlur .2s ease-in-out forwards;
    animation-delay: .2s;
  }

  @keyframes backdropBlur {
    0% {
      backdrop-filter: blur(0px);
    }
    100% {
      backdrop-filter: blur(5px);
    } 
  }

  #modelTrainingProgress::-webkit-progress-bar {
    @apply rounded-full overflow-hidden bg-zinc-800;
  }

  #modelTrainingProgress::-webkit-progress-value {
    @apply bg-white;
  }

  @keyframes rippleAnimation {
    100% {
      transform: scale(1.4);
      opacity: 0;
    }
  }

  .listening,
  .listening > * {
    position: relative;
    z-index: 1;
  }

  .listening::before,
  .listening::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: linear-gradient(
      45deg,
      var(--color-secondary),
      var(--color-primary)
    );
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
  }

  .listening:before {
    z-index: 0;
    animation: 1s ease-out rippleAnimation infinite;
    animation-play-state: var(--listening-play-state-1) !important;
  }

  .listening::after {
    z-index: 0;
    animation: 1s .5s ease-out rippleAnimation infinite;
    animation-play-state: var(--listening-play-state-2) !important;
  }
</style>

<script>
  import { ChartManager, UIManager } from "../lib/chartManager"
  import type { TrainingData } from "../lib/chartManager"

  class StateWebSocketManager {
    private socket: WebSocket | null = null
    private readonly reconnectDelay = 5000
    private readonly serverUrl: string
    private readonly onMessage: (message: any) => void
    private readonly onClose: () => void
    private readonly onError: () => void

    constructor(
      serverUrl: string,
      onMessage: (message: any) => void,
      onClose: () => void,
      onError: () => void
    ) {
      this.serverUrl = serverUrl
      this.onMessage = onMessage
      this.onClose = onClose
      this.onError = onError
    }

    public connect(): void {
      this.socket = new WebSocket(this.serverUrl)

      this.socket.addEventListener("open", () => {
        console.log(`Connected to the server at ${this.serverUrl}`)
      })

      this.socket.addEventListener("message", (event) => {
        try {
          const message = JSON.parse(event.data)
          this.onMessage(message)
        } catch (error) {
          console.error(`Error parsing message: ${error}`)
        }
      })

      this.socket.addEventListener("close", () => {
        console.log(`Disconnected from the server at ${this.serverUrl}`)
        this.onClose()
        this.attemptReconnect()
      })

      this.socket.addEventListener("error", (error) => {
        console.error(`WebSocket error: ${error}`)
        this.onError()
        this.socket?.close()
      })
    }

    private attemptReconnect(): void {
      setTimeout(() => this.connect(), this.reconnectDelay)
    }

    public send(data: any): void {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) {
        this.socket.send(JSON.stringify(data))
      } else {
        console.error("WebSocket is not open. Cannot send data.")
      }
    }

    public close(): void {
      if (this.socket) {
        this.socket.close()
      }
    }
  }

  class StateDialogManager {
    private readonly dialog: HTMLDialogElement
    private readonly verboseSection: HTMLDivElement
    private readonly failedSection: HTMLDivElement
    private readonly spinner: HTMLDivElement
    private readonly chartProgress: HTMLDivElement
    private readonly heading: HTMLHeadingElement
    private readonly paragraph: HTMLParagraphElement

    constructor(dialogId: string) {
      this.dialog = document.getElementById(dialogId) as HTMLDialogElement

      if (!this.dialog) {
        throw new Error(`Dialog with ID ${dialogId} not found`)
      }

      this.verboseSection = this.dialog.querySelector("#stateVerbose") as HTMLDivElement
      this.failedSection = this.dialog.querySelector("#stateFailed") as HTMLDivElement
      this.spinner = this.dialog.querySelector("#spinner") as HTMLDivElement
      this.chartProgress = this.dialog.querySelector("#chart_progress") as HTMLDivElement
      this.heading = this.dialog.querySelector("h2") as HTMLHeadingElement
      this.paragraph = this.dialog.querySelector("p") as HTMLParagraphElement

      this.validateElements()
    }

    private validateElements(): void {
      if (!this.verboseSection || !this.failedSection || !this.spinner || !this.chartProgress || !this.heading || !this.paragraph) {
        throw new Error("One or more required elements are missing in the dialog")
      }
    }

    public showVerbose(): void {
      this.verboseSection.hidden = false
      this.failedSection.hidden = true
      this.showDialog()
    }

    public showFailed(): void {
      this.verboseSection.hidden = true
      this.failedSection.hidden = false
      this.showDialog()
    }

    private showDialog(): void {
      this.dialog.showModal()
      this.dialog.classList.add("show")
    }

    public hideDialog(): void {
      this.dialog.classList.remove("show")
      setTimeout(() => {
        this.dialog.close()
      }, 200)
    }

    public showSpinner(): void {
      this.spinner.hidden = false
      this.chartProgress.hidden = true
    }

    public showChart(): void {
      this.spinner.hidden = true
      this.chartProgress.hidden = false
    }

    public updateHeading(text: string): void {
      this.heading.innerText = text
    }

    public updateParagraph(text: string): void {
      this.paragraph.innerText = text
    }
  }

  class AudioRecorder {
    private mediaRecorder: MediaRecorder | null = null
    private recordingInterval: NodeJS.Timeout | null = null
    private readonly webSocket: WebSocket
    private readonly listeningButtonAnimator: ListeningButtonAnimator

    constructor(webSocket: WebSocket, listeningButtonAnimator: ListeningButtonAnimator) {
      this.webSocket = webSocket
      this.listeningButtonAnimator = listeningButtonAnimator
    }

    public async start(maxDuration = 21000, transmissionInterval = 3000): Promise<void> {
      try {
        await this.startRecordingCycle(transmissionInterval)

        this.recordingInterval = setInterval(() => {
          this.startRecordingCycle(transmissionInterval)
        }, transmissionInterval)

        setTimeout(() => this.stop(), maxDuration)
      } catch (error) {
        this.handleError(error as Error)
      }
    }

    private async startRecordingCycle(transmissionInterval: number): Promise<void> {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      this.mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm; codecs=opus" })

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          const blob = new Blob([event.data], { type: "audio/webm; codecs=opus" })
          this.webSocket.send(blob)
          this.mediaRecorder?.stop()
        }
      }

      this.mediaRecorder.start()

      setTimeout(() => {
        if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
          this.mediaRecorder.requestData()
        }
      }, transmissionInterval)
    }

    private handleError(error: Error): void {
      const errorMessages: Record<string, string> = {
        NotAllowedError: "Microphone access denied. Please allow access to the microphone in your browser settings.",
        NotFoundError: "No microphone found. Please connect a microphone and try again.",
        NotReadableError: "Microphone is not readable. Please check your microphone settings.",
        OverconstrainedError: "Microphone constraints are not met. Please check your microphone settings."
      }

      if (error.name in errorMessages) {
        alert(errorMessages[error.name])
      } else {
        console.error("Error starting audio recording: ", error)
      }
    }

    public stop(): void {
      if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
        this.mediaRecorder.stop()
      }
      if (this.recordingInterval) {
        clearInterval(this.recordingInterval)
        this.recordingInterval = null
      }
      this.listeningButtonAnimator.stopAnimation()
    }
  }

  class ListeningButtonAnimator {
    private readonly button: HTMLElement
    private startAnimationTime = 0
    private animationIsRunning = false
    private animationIsStopping = false
    private readonly animationDurations: Record<string, number> = {
      "--listening-play-state-1": 1000,
      "--listening-play-state-2": 1500
    }
    private readonly gapDuration = 500

    constructor(buttonId: string) {
      this.button = document.getElementById(buttonId) as HTMLElement

      if (!this.button) {
        throw new Error(`Button with ID ${buttonId} not found`)
      }
    }

    public startAnimation(): void {
      if (this.animationIsRunning) return

      this.startAnimationTime = Date.now()
      this.button.classList.add("listening")
      this.animationIsRunning = true
    }

    public stopAnimation(): void {
      if (!this.animationIsRunning || this.animationIsStopping) return

      this.animationIsStopping = true

      this.button.addEventListener("animationiteration", (e) => {
        const delta = Date.now() - this.startAnimationTime
        const closestName = this.getClosestAnimationName(delta)
        this.pauseAnimation(this.button, closestName)

        setTimeout(() => {
          this.button.classList.remove("listening")
          this.resumeAllAnimations(this.button)
          this.animationIsStopping = false
          this.animationIsRunning = false
        }, this.gapDuration)
      }, { once: true})
    }

    private getClosestAnimationName(delta: number): string {
      return Object.keys(this.animationDurations).reduce((prev, curr) => {
        const prevDuration = this.animationDurations[prev as keyof typeof this.animationDurations];
        const currDuration = this.animationDurations[curr as keyof typeof this.animationDurations];

        const prevDivision = delta / prevDuration;
        const currDivision = delta / currDuration;

        const prevDelta = Math.abs(Math.round(prevDivision) - prevDivision);
        const currDelta = Math.abs(Math.round(currDivision) - currDivision);

        return prevDelta < currDelta ? prev : curr;
      });
    }

    private pauseAnimation(el: HTMLElement, animationName: string): void {
      el.style.setProperty(animationName, "paused")
    }

    private resumeAllAnimations(el: HTMLElement): void {
      Object.keys(this.animationDurations).forEach((name) => {
        el.style.setProperty(name, "running");
      });
    }

    public isAnimating(): boolean {
      return this.animationIsRunning
    }
  }

  function initializeServerState(): void {
    const modelTrainingChart = document.getElementById("modelTrainingChart") as HTMLCanvasElement
    const modelTrainingProgress = document.getElementById("modelTrainingProgress") as HTMLProgressElement
    const modelTrainingProgressText = document.getElementById("modelTrainingProgressText") as HTMLParagraphElement
    const modelTrainingETA = document.getElementById("modelTrainingETA") as HTMLParagraphElement

    if (!modelTrainingChart || !modelTrainingProgress || !modelTrainingProgressText || !modelTrainingETA) {
      console.error("One or more required elements are missing")
      return
    }

    const uiManager = new UIManager(modelTrainingProgress, modelTrainingProgressText, modelTrainingETA)
    const chartManager = new ChartManager(modelTrainingChart, uiManager)
    const dialogManager = new StateDialogManager("stateDialog")

    const handleServerMessage = (message: any) => {
      if (message.state === "ready") {
        dialogManager.hideDialog()
        return
      } else {
        dialogManager.showVerbose()
      }

      if (message.state === "training_model") {
        dialogManager.showChart()
      } else {
        dialogManager.showSpinner()
      }

      const stateHeadings: Record<string, string> = {
        loading_server: "The server is loading",
        downloading_songs: "Downloading songs",
        downloading_metadata: "Downloading song's metadata",
        processing_songs: "Processing songs",
        loading_model: "The model is loading",
        training_model: "The model is being trained",
        storing_embeddings: "Storing embeddings",
      }

      if (message.state in stateHeadings) {
        dialogManager.updateHeading(stateHeadings[message.state])
      }

      if (message.state === "training_model" && message.data) {
        const data = message.data as TrainingData
        chartManager.update(data)
      }
    }

    const stateWebSocketManager = new StateWebSocketManager(
      "ws://localhost:5000",
      handleServerMessage,
      () => dialogManager.showFailed(),
      () => dialogManager.showFailed()
    )

    stateWebSocketManager.connect()
  }

  function initializePredictionServer(): WebSocket {
    const predictionSocket = new WebSocket("ws://localhost:5001");

    predictionSocket.addEventListener("open", () => {
      console.log("Connected to the prediction server");
    });

    predictionSocket.addEventListener("message", (event) => {
      console.log(event);
    });

    predictionSocket.addEventListener("close", () => {
      console.log("Disconnected from the prediction server");
    });

    predictionSocket.addEventListener("error", (error) => {
      console.error("WebSocket error: ", error);
    });

    return predictionSocket;
  }

  function initializeListeningButton(): void {
    const predictionSocket = initializePredictionServer()
    const buttonAnimator = new ListeningButtonAnimator("listeningButton")
    const audioRecorder = new AudioRecorder(predictionSocket, buttonAnimator)

    const listeningButton = document.getElementById("listeningButton") as HTMLElement
    if (!listeningButton) {
      console.error("Listening button not found")
      return
    }

    listeningButton.addEventListener("click", () => {
      if (!buttonAnimator.isAnimating()) {
        buttonAnimator.startAnimation()
        audioRecorder.start()
      } else {
        console.log('Stop')
        audioRecorder.stop()
        buttonAnimator.stopAnimation()
      }
    })
  }

  function initializeApp(): void {
    initializeServerState()
    initializeListeningButton()
  }

  initializeApp()
</script>